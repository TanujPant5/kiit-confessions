<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KIIT Confessions // TRON</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font 'Inter' for readability -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <!-- Custom Styles for Tron Theme -->
    <style>
        /* Base styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a1a;
            /* Dark blue/black */
            color: #00e5ff;
            /* Neon blue */
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff;
        }

        /* Helper for glowing effect */
        .glow {
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff, 0 0 15px #00e5ff;
        }

        /* Neon Borders */
        .neon-border {
            border: 2px solid #00e5ff;
            box-shadow: 0 0 10px #00e5ff, 0 0 15px #00e5ff inset;
            border-radius: 0.5rem;
            /* 8px */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #00e5ff;
            border-radius: 4px;
            box-shadow: 0 0 5px #00e5ff;
        }

        /* Textarea and Button Styling */
        textarea,
        button {
            font-family: 'Inter', sans-serif;
            background-color: rgba(0, 229, 255, 0.05);
            /* Faint blue */
            border: 1px solid #00e5ff;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff;
            transition: all 0.3s ease;
        }

        textarea::placeholder {
            color: #00e5ff;
            opacity: 0.5;
        }

        textarea:focus {
            outline: none;
            background-color: rgba(0, 229, 255, 0.1);
            box-shadow: 0 0 10px #00e5ff;
        }

        button:hover {
            background-color: #00e5ff;
            color: #0a0a1a;
            text-shadow: none;
            box-shadow: 0 0 15px #00e5ff;
        }

        /* Style for text input */
        input[type="text"] {
            font-family: 'Inter', sans-serif;
            background-color: rgba(0, 229, 255, 0.05);
            /* Faint blue */
            border: 1px solid #00e5ff;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff;
            transition: all 0.3s ease;
        }

        input[type="text"]::placeholder {
            color: #00e5ff;
            opacity: 0.5;
        }

        input[type="text"]:focus {
            outline: none;
            background-color: rgba(0, 229, 255, 0.1);
            box-shadow: 0 0 10px #00e5ff;
        }


        /* Feed container */
        #feedContainer {
            background-color: rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        /* Individual message bubbles */
        .message-bubble {
            background-color: rgba(30, 30, 50, 0.7);
            /* Dark grey-blue */
            border: 1px solid #007a8a;
            /* Darker cyan */
            text-shadow: 0 0 3px #00e5ff;
            word-wrap: break-word;
            /* Ensure long words break */
            white-space: pre-wrap;
            /* Respect newlines */
            padding: 0.5rem 0.75rem;
            /* Tighter padding */
        }

        /* "My" message bubbles */
        .my-message {
            background-color: rgba(0, 50, 100, 0.8);
            /* Dark blue */
            border: 1px solid #00e5ff;
            /* Bright cyan */
            align-self: flex-end;
        }

        /* Timestamp styling */
        .timestamp {
            font-size: 0.65rem;
            /* 10px */
            color: #00e5ff;
            opacity: 0.6;
            text-shadow: none;
            margin-top: 2px;
            /* Tighter margin */
            display: flex; /* NEW: for edit/delete buttons */
            justify-content: flex-end; /* NEW */
            align-items: center; /* NEW */
            gap: 4px; /* NEW */
        }

        /* NEW: Edit/Delete button styling */
        .edit-btn, .delete-btn {
            background: none;
            border: none;
            padding: 0 2px;
            margin: 0;
            color: #00e5ff;
            opacity: 0.5;
            cursor: pointer;
            text-decoration: underline;
            font-size: 0.6rem; /* 9px */
            text-shadow: none;
        }
        .edit-btn:hover, .delete-btn:hover {
            opacity: 1;
            text-shadow: 0 0 5px #00e5ff;
        }

        /* NEW: Edited marker styling */
        .edited-marker {
            font-size: 0.6rem;
            opacity: 0.5;
            margin-right: 4px;
        }


        /* Navigation styling */
        .nav-item {
            cursor: pointer;
            padding: 8px 16px;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .nav-item.active,
        .nav-item:hover {
            opacity: 1;
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff;
            border-bottom-color: #00e5ff;
        }

        /* Profile picture in chat */
        .chat-pfp {
            width: 32px;
            /* Smaller */
            height: 32px;
            /* Smaller */
            border-radius: 50%;
            border: 2px solid #00e5ff;
            object-fit: cover;
            flex-shrink: 0;
        }

        /* Typing indicator styling */
        #typingIndicator {
            height: 1.5rem;
            /* 24px */
            font-size: 0.875rem;
            /* 14px */
            color: #00e5ff;
            opacity: 0.7;
            text-shadow: 0 0 5px #00e5ff;
            transition: opacity 0.3s ease;
        }
    </style>
</head>

<body class="flex flex-col h-screen bg-[#0a0a1a]">

    <!-- Header -->
    <header class="flex justify-between items-center p-2 sm:p-4 border-b-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20 gap-2 sm:gap-4">
        <!-- Left Side: Title -->
        <h1 class="text-xl sm:text-3xl font-bold glow">KIIT CONFESSIONS</h1>

        <!-- Right Side: Nav and Profile -->
        <div class="flex items-center gap-2 sm:gap-4">
            <nav class="flex text-base sm:text-lg gap-2 sm:gap-4">
                <div id="navConfessions" class="nav-item">CONFESSIONS</div>
                <div id="navChat" class="nav-item active">CHAT</div>
            </nav>
            <button id="profileButton" class="p-2 rounded-full hover:bg-gray-700 transition" title="Edit Profile">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col overflow-hidden"> <!-- Full-height chat area -->
        <!-- Feed Container -->
        <div id="feedContainer" class="flex-1 flex flex-col p-2 sm:p-4 gap-2 overflow-y-auto"> <!-- Removed neon-border, added padding -->
            <!-- Messages will be injected here -->
            <div id="loading" class="text-center p-4">CONNECTING TO GRID...</div>
        </div>

        <!-- Typing Indicator -->
        <div id="typingIndicator" class="px-4 h-6 text-sm opacity-70">&nbsp;</div>

        <!-- Input Forms (one for each page) -->
        <form id="confessionForm" class="hidden gap-3 p-2 sm:p-4 border-t-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20">
            <textarea id="confessionInput" rows="2"
                class="flex-1 p-3 rounded-lg resize-none focus:outline-none"
                placeholder="TYPE YOUR CONFESSION... (SHIFT+ENTER FOR NEW LINE)" required></textarea>
            <button id="confessionButton" type="submit"
                class="px-6 py-2 rounded-lg font-bold">CONFESS</button>
        </form>

        <form id="chatForm" class="flex gap-3 p-2 sm:p-4 border-t-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20">
            <textarea id="chatInput" rows="2" class="flex-1 p-3 rounded-lg resize-none focus:outline-none"
                placeholder="TYPE YOUR MESSAGE... (SHIFT+ENTER FOR NEW LINE)" required></textarea>
            <button id="chatButton" type="submit" class="px-6 py-2 rounded-lg font-bold">SEND</button>
        </form>
    </main>

    <!-- Footer -->
    <!-- <footer class="text-center text-xs opacity-50 p-1 sm:p-2 border-t border-[#00e5ff]/20">
        ANONYMOUS GRID // DISCONNECT ANYTIME
    </footer> -->

    <!-- Profile Modal -->
    <div id="profileModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-2xl font-bold glow">EDIT PROFILE</h2>

            <!-- Username Input -->
            <div class="flex flex-col gap-2">
                <label for="modalUsernameInput" class="text-sm opacity-70">Username</label>
                <input type="text" id="modalUsernameInput" placeholder="SET YOUR USERNAME..."
                    class="w-full p-3 rounded-lg focus:outline-none" />
            </div>

            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="modalCloseButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="modalSaveButton" class="flex-1 px-6 py-2 rounded-lg font-bold">SAVE</button>
            </div>
        </div>
    </div>

    <!-- NEW: Edit Message Modal -->
    <div id="editModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-2xl font-bold glow">EDIT MESSAGE</h2>
            
            <textarea id="modalEditTextArea" rows="4" class="w-full p-3 rounded-lg resize-none focus:outline-none"></textarea>

            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="editModalCancelButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="editModalSaveButton" class="flex-1 px-6 py-2 rounded-lg font-bold">SAVE</button>
            </div>
        </div>
    </div>

    <!-- NEW: Confirm Delete Modal -->
    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-xl font-bold glow">DELETE MESSAGE</h2>
            <p id="confirmModalText" class="text-base opacity-90">Are you sure you want to permanently delete this message?</p>
            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="confirmModalNoButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="confirmModalYesButton" class="flex-1 px-6 py-2 rounded-lg font-bold bg-red-800 border-red-500 hover:bg-red-600">DELETE</button>
            </div>
        </div>
    </div>


    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import {
            initializeApp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            signInAnonymously
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            onSnapshot,
            query,
            serverTimestamp,
            doc,
            setDoc,
            getDoc,
            orderBy,
            updateDoc, // --- NEW
            deleteDoc  // --- NEW
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyCtFOOGfjbeLM-bAT5i2J601w9_95MQlxs",
            authDomain: "kiit-confessions.firebaseapp.com",
            projectId: "kiit-confessions",
            storageBucket: "kiit-confessions.firebasestorage.app",
            messagingSenderId: "844059847809",
            appId: "1:844059847809:web:98a8a39a3a33c2dd7d3180",
            measurementId: "G-2JRL8TMMV7"
        };


        // --- DOM Elements ---
        const feedContainer = document.getElementById('feedContainer');
        const loading = document.getElementById('loading');
        const navConfessions = document.getElementById('navConfessions');
        const navChat = document.getElementById('navChat');
        const confessionForm = document.getElementById('confessionForm');
        const confessionInput = document.getElementById('confessionInput');
        const confessionButton = document.getElementById('confessionButton');
        const chatForm = document.getElementById('chatForm');
        const chatInput = document.getElementById('chatInput');
        const chatButton = document.getElementById('chatButton');
        const typingIndicator = document.getElementById('typingIndicator');

        // --- Modal DOM Elements ---
        const profileButton = document.getElementById('profileButton');
        const profileModal = document.getElementById('profileModal');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const modalSaveButton = document.getElementById('modalSaveButton');
        const modalUsernameInput = document.getElementById('modalUsernameInput');

        // --- NEW: Edit/Delete Modal Elements ---
        const editModal = document.getElementById('editModal');
        const modalEditTextArea = document.getElementById('modalEditTextArea');
        const editModalCancelButton = document.getElementById('editModalCancelButton');
        const editModalSaveButton = document.getElementById('editModalSaveButton');

        const confirmModal = document.getElementById('confirmModal');
        const confirmModalText = document.getElementById('confirmModalText');
        const confirmModalNoButton = document.getElementById('confirmModalNoButton');
        const confirmModalYesButton = document.getElementById('confirmModalYesButton');

        // --- App State ---
        let db;
        let auth;
        let currentUserId = null;
        let currentUsername = 'Anonymous';
        let currentProfilePhotoURL = null;
        
        // Cache for all user profiles
        let userProfiles = {}; 
        
        let confessionsCollection;
        let chatCollection;
        let typingStatusCollection;
        let unsubscribeConfessions = () => {};
        let unsubscribeChat = () => {};
        let unsubscribeUserProfiles = () => {};
        let unsubscribeTypingStatus = () => {};
        let currentPage = 'chat';
        
        let typingTimeout = null;
        
        // --- NEW: State for editing/deleting ---
        let docToEditId = null;
        let collectionToEdit = null;
        let deleteCallback = null; // Stores the function to run on delete confirm

        // --- Firebase Initialization ---
        async function initFirebase() {
            try {
                if (firebaseConfig.apiKey === "AIzaSyCtFOOGfjbeLM-bAT5i2J601w9_95MQlxs") {
                    console.log("Firebase config loaded.");
                } else {
                    throw new Error("Firebase configuration is missing or incorrect.");
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                const userCredential = await signInAnonymously(auth);
                currentUserId = userCredential.user.uid;
                console.log("Firebase initialized and user signed in:", currentUserId);

                // Start listening for all user profiles
                listenForUserProfiles();
                
                await loadUserProfile(); // Load local user's data

                confessionsCollection = collection(db, 'confessions');
                chatCollection = collection(db, 'chat');
                typingStatusCollection = collection(db, 'typingStatus');

                showPage(currentPage); // This will be 'chat'

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                loading.textContent = "Error: Could not connect to the grid. Refresh page.";
                if (error.message.includes("api-key-not-valid")) {
                    loading.textContent = "Error: Firebase API Key is not valid. Check console.";
                }
            }
        }

        // --- User Profile Functions ---

        // Listen for all user profiles and cache them
        function listenForUserProfiles() {
            const usersCollection = collection(db, 'users');
            unsubscribeUserProfiles = onSnapshot(usersCollection, (snapshot) => {
                snapshot.docs.forEach(doc => {
                    userProfiles[doc.id] = doc.data();
                });
                console.log("User profiles cache updated:", userProfiles);
                // Re-render the current feed with new profile data
                if (currentPage === 'chat') {
                    listenForChat(true); // 'true' to signal a re-render
                } else {
                    listenForConfessions(true); // 'true' to signal a re-render
                }
            });
        }
        
        // Load the current user's profile
        async function loadUserProfile() {
            if (!db || !currentUserId) return;
            const userDocRef = doc(db, 'users', currentUserId);
            const userDoc = await getDoc(userDocRef);

            if (userDoc.exists()) {
                const data = userDoc.data();
                currentUsername = data.username || 'Anonymous';
                currentProfilePhotoURL = data.profilePhotoURL || null;
            } else {
                currentUsername = 'Anonymous';
                currentProfilePhotoURL = null;
            }
            modalUsernameInput.value = currentUsername === 'Anonymous' ? '' : currentUsername;
        }

        // Save the current user's profile
        async function handleProfileSave() {
            if (!db || !currentUserId) return;

            modalSaveButton.textContent = "SAVING...";
            modalSaveButton.disabled = true;

            const newUsername = modalUsernameInput.value.trim() || 'Anonymous';
            
            // Generate photo URL from username
            let newProfilePhotoURL = null;
            if (newUsername && newUsername !== 'Anonymous') {
                const firstLetter = newUsername.charAt(0).toUpperCase();
                // Use a 32px placeholder to match the UI
                newProfilePhotoURL = `https://placehold.co/32x32/0a0a1a/00e5ff?text=${firstLetter}`; 
            } else {
                newProfilePhotoURL = `https://placehold.co/32x32/00e5ff/0a0a1a?text=?`;
            }
            
            try {
                // Save username and photo URL to Firestore
                const userDocRef = doc(db, 'users', currentUserId);
                await setDoc(userDocRef, {
                    username: newUsername,
                    profilePhotoURL: newProfilePhotoURL 
                }, { merge: true });

                // Update local app state (will also be updated by snapshot listener)
                currentUsername = newUsername;
                currentProfilePhotoURL = newProfilePhotoURL;

                closeProfileModal();
                modalSaveButton.textContent = "SAVE";
                modalSaveButton.disabled = false;

            } catch (error) {
                console.error("Error saving profile: ", error);
                modalSaveButton.textContent = "ERROR!";
                modalSaveButton.disabled = false;
                setTimeout(() => {
                    modalSaveButton.textContent = "SAVE";
                }, 2000);
            }
        }

        // --- Modal Controls ---
        function openProfileModal() {
            modalUsernameInput.value = currentUsername === 'Anonymous' ? '' : currentUsername;
            profileModal.classList.remove('hidden');
        }

        function closeProfileModal() {
            profileModal.classList.add('hidden');
        }

        // --- NEW: Edit/Delete Modal Controls & Logic ---
        function showEditModal(docId, collectionName, currentText) {
            docToEditId = docId;
            collectionToEdit = collectionName;
            modalEditTextArea.value = currentText;
            editModal.classList.remove('hidden');
        }
        
        function closeEditModal() {
            editModal.classList.add('hidden');
            docToEditId = null;
            collectionToEdit = null;
        }

        async function saveEdit() {
            const newText = modalEditTextArea.value.trim();
            if (newText && docToEditId && collectionToEdit) {
                editModalSaveButton.textContent = "SAVING...";
                editModalSaveButton.disabled = true;
                try {
                    const docRef = doc(db, collectionToEdit, docToEditId);
                    await updateDoc(docRef, {
                        text: newText,
                        edited: true // Add 'edited' marker
                    });
                    closeEditModal();
                } catch (error) {
                    console.error("Error updating document:", error);
                    // This error will trigger if rules fail (e.g., > 5 mins)
                    alert("Error: Could not save edit. The 5-minute edit window may have expired.");
                }
                editModalSaveButton.textContent = "SAVE";
                editModalSaveButton.disabled = false;
            }
        }

        function showConfirmModal(callback) {
            deleteCallback = callback; // Store the delete function
            confirmModal.classList.remove('hidden');
        }
        
        function closeConfirmModal() {
            confirmModal.classList.add('hidden');
            deleteCallback = null;
        }
        
        async function handleDelete() {
            if (deleteCallback) {
                confirmModalYesButton.textContent = "DELETING...";
                confirmModalYesButton.disabled = true;
                try {
                    await deleteCallback(); // Run the stored delete function
                } catch (error) {
                    console.error("Error deleting document:", error);
                    alert("Error: Could not delete message.");
                }
                closeConfirmModal();
                confirmModalYesButton.textContent = "DELETE";
                confirmModalYesButton.disabled = false;
            }
        }

        // --- Page Navigation ---
        function showPage(page) {
            currentPage = page;
            
            // Stop all listeners
            unsubscribeConfessions();
            unsubscribeChat();
            unsubscribeTypingStatus();
            typingIndicator.innerHTML = '&nbsp;'; // Clear typing indicator

            if (page === 'confessions') {
                navConfessions.classList.add('active');
                navChat.classList.remove('active');
                confessionForm.classList.remove('hidden');
                confessionForm.classList.add('flex');
                chatForm.classList.add('hidden');
                chatForm.classList.remove('flex');
                typingIndicator.classList.add('hidden'); // Hide typing on confessions page
                listenForConfessions();
            } else {
                navChat.classList.add('active');
                navConfessions.classList.remove('active');
                chatForm.classList.remove('hidden');
                chatForm.classList.add('flex');
                confessionForm.classList.add('hidden');
                confessionForm.classList.remove('flex');
                typingIndicator.classList.remove('hidden'); // Show typing on chat page
                listenForChat();
                listenForTyping(); // Start listening for typing
            }
        }

        // --- Real-time Data Listeners ---
        // Store the last rendered docs to allow re-rendering without a new query
        let lastConfessionDocs = [];
        let lastChatDocs = [];

        function listenForConfessions(isRerender = false) { 
            if (isRerender) {
                renderFeed(lastConfessionDocs, 'confessions');
                return;
            }
            unsubscribeChat(); 
            feedContainer.innerHTML =
                '<div id="loading" class="text-center p-4">LOADING CONFESSIONS...</div>';
        
            const q = query(confessionsCollection, orderBy("timestamp", "asc"));
            unsubscribeConfessions = onSnapshot(q, (snapshot) => {
                lastConfessionDocs = snapshot.docs; // Cache docs
                renderFeed(lastConfessionDocs, 'confessions');
            }, (error) => {
                console.error("Error listening to confessions:", error);
                loading.textContent = "Error loading confessions.";
            });
        }

        function listenForChat(isRerender = false) {
            if (isRerender) {
                renderFeed(lastChatDocs, 'chat');
                return;
            }
            unsubscribeConfessions(); 
            feedContainer.innerHTML =
                '<div id="loading" class="text-center p-4">LOADING CHAT...</div>';

            const q = query(chatCollection, orderBy("timestamp", "asc"));
            unsubscribeChat = onSnapshot(q, (snapshot) => {
                lastChatDocs = snapshot.docs; // Cache docs
                renderFeed(lastChatDocs, 'chat');
            }, (error) => {
                console.error("Error listening to chat:", error);
                loading.textContent = "Error loading chat.";
            });
        }

        // --- Typing Indicator Logic ---
        function listenForTyping() {
            unsubscribeTypingStatus = onSnapshot(typingStatusCollection, (snapshot) => {
                const now = Date.now();
                const typingUsers = [];

                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const userId = doc.id;
                    
                    // Check if user is typing and it's not us
                    // And timestamp is recent (within 5 seconds)
                    if (data.isTyping && userId !== currentUserId && (now - data.timestamp < 5000)) {
                        // Look up username from cache
                        const username = userProfiles[userId]?.username || 'Someone';
                        typingUsers.push(username);
                    }
                });

                if (typingUsers.length === 0) {
                    typingIndicator.innerHTML = '&nbsp;'; // Non-breaking space
                } else if (typingUsers.length === 1) {
                    typingIndicator.textContent = `${typingUsers[0]} is typing...`;
                } else if (typingUsers.length === 2) {
                    typingIndicator.textContent = `${typingUsers[0]} and ${typingUsers[1]} are typing...`;
                } else {
                    typingIndicator.textContent = 'Several users are typing...';
                }
            });
        }

        // --- Function to update our typing status ---
        async function updateTypingStatus(isTyping) {
            if (!db || !currentUserId) return;
            
            // Clear previous timeout if it exists
            if (typingTimeout) {
                clearTimeout(typingTimeout);
                typingTimeout = null;
            }

            const typingDocRef = doc(db, 'typingStatus', currentUserId);
            
            if (isTyping) {
                // User is typing, set status to true with timestamp
                await setDoc(typingDocRef, {
                    isTyping: true,
                    timestamp: Date.now() // Use local timestamp for quick updates
                });

                // Set a timeout to automatically set typing to false after 3 seconds
                typingTimeout = setTimeout(() => {
                    updateTypingStatus(false);
                }, 3000); // 3 second timeout

            } else {
                // User stopped typing, set status to false
                await setDoc(typingDocRef, {
                    isTyping: false,
                    timestamp: Date.now()
                });
            }
        }


        // --- Helper Function to Format Timestamp ---
        function formatTimestamp(firebaseTimestamp) {
            if (!firebaseTimestamp) return '...';
            const date = firebaseTimestamp.toDate();
            return date.toLocaleString([], { 
                dateStyle: 'short', 
                timeStyle: 'short' 
            });
        }

        // --- Render Function (UPDATED) ---
        function renderFeed(docs, type) {
            feedContainer.innerHTML = ''; 
            if (docs.length === 0) {
                const loadingEl = document.createElement('div');
                loadingEl.id = 'loading';
                loadingEl.className = 'text-center p-4';
                loadingEl.textContent = `NO ${type.toUpperCase()} YET. BE THE FIRST!`;
                feedContainer.appendChild(loadingEl);
                return;
            }

            let lastUserId = null; 

            docs.forEach(docInstance => { // Renamed 'doc' to 'docInstance' to avoid conflict
                const data = docInstance.data();
                const text = data.text || '...';
                const time = formatTimestamp(data.timestamp);
                const docUserId = data.userId;
                
                // Look up profile from cache
                const profile = userProfiles[docUserId] || {};
                const username = profile.username || 'Anonymous';
                const photoURL = profile.profilePhotoURL || `https://placehold.co/32x32/00e5ff/0a0a1a?text=${username.charAt(0).toUpperCase() || '?'}`;

                const isMine = currentUserId && docUserId === currentUserId;
                
                const isConsecutive = (docUserId && docUserId === lastUserId);
                lastUserId = docUserId; 

                const alignWrapper = document.createElement('div');
                alignWrapper.className = `flex w-full ${isMine ? 'justify-end' : 'justify-start'}`;

                const bubble = document.createElement('div');
                bubble.className = `message-bubble rounded-lg max-w-xs sm:max-w-md md:max-w-lg ${isMine ? 'my-message' : ''} ${isConsecutive ? 'mt-0.5' : 'mt-2'}`; 

                if (!isConsecutive) {
                    const headerElement = document.createElement('div');
                    headerElement.className = `flex items-center gap-1.5 mb-1 ${isMine ? 'justify-end' : ''}`; 
                    
                    const imgElement = document.createElement('img');
                    imgElement.src = photoURL;
                    imgElement.className = `chat-pfp ${isMine ? 'order-2' : 'order-1'}`; 
                    
                    const usernameElement = document.createElement('div');
                    usernameElement.className = `font-bold text-sm opacity-70 ${isMine ? 'order-1 text-right' : 'order-2 text-left'}`;
                    usernameElement.textContent = username;

                    headerElement.appendChild(imgElement);
                    headerElement.appendChild(usernameElement);
                    bubble.appendChild(headerElement);
                }

                const textElement = document.createElement('p');
                textElement.className = `${isMine ? 'text-right' : 'text-left'}`;
                textElement.textContent = text;
                bubble.appendChild(textElement);

                const timeElement = document.createElement('div');
                timeElement.className = 'timestamp text-right';
                
                // Add (edited) marker if data.edited is true
                if (data.edited) {
                    const editedMarker = document.createElement('span');
                    editedMarker.className = 'edited-marker';
                    editedMarker.textContent = '(edited)';
                    timeElement.appendChild(editedMarker);
                }
                
                const timeText = document.createElement('span');
                timeText.textContent = time;
                timeElement.appendChild(timeText);

                // Add Edit/Delete buttons if isMine
                if (isMine) {
                    // Check for 5-min edit window
                    const now = Date.now();
                    const messageTime = data.timestamp ? data.timestamp.toDate().getTime() : 0;
                    const isEditable = (now - messageTime < 300000); // 5 mins in ms

                    if (isEditable) {
                        const editBtn = document.createElement('button');
                        editBtn.textContent = 'Edit';
                        editBtn.className = 'edit-btn';
                        editBtn.onclick = () => showEditModal(docInstance.id, currentPage, text);
                        timeElement.appendChild(editBtn);
                    }

                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.onclick = () => {
                        showConfirmModal(async () => {
                            await deleteDoc(doc(db, currentPage, docInstance.id));
                        });
                    };
                    timeElement.appendChild(deleteBtn);
                }

                bubble.appendChild(timeElement);

                alignWrapper.appendChild(bubble);
                feedContainer.appendChild(alignWrapper);
            });

            // Auto-scroll to bottom
            feedContainer.scrollTop = feedContainer.scrollHeight;
        }

        // --- Form Submission ---
        async function postConfession(e) {
            e.preventDefault();
            const text = confessionInput.value.trim();
            if (text && db) {
                try {
                    await addDoc(confessionsCollection, {
                        text: text,
                        timestamp: serverTimestamp(),
                        userId: currentUserId // Only save the user's ID
                        // 'edited' field is not added on creation
                    });
                    confessionInput.value = '';
                    updateTypingStatus(false); // Clear typing status on send
                } catch (error) {
                    console.error("Error adding confession: ", error);
                }
            }
        }

        async function postChatMessage(e) {
            e.preventDefault();
            const text = chatInput.value.trim();
            if (text && db) {
                try {
                    await addDoc(chatCollection, {
                        text: text,
                        timestamp: serverTimestamp(),
                        userId: currentUserId // Only save the user's ID
                    });
                    chatInput.value = '';
                    updateTypingStatus(false); // Clear typing status on send
                } catch (error)
                 {
                    console.error("Error adding chat message: ", error);
                }
            }
        }

        // --- Event Listeners ---
        confessionForm.addEventListener('submit', postConfession);
        chatForm.addEventListener('submit', postChatMessage);
        navConfessions.addEventListener('click', () => showPage('confessions'));
        navChat.addEventListener('click', () => showPage('chat'));

        // --- Modal Event Listeners ---
        profileButton.addEventListener('click', openProfileModal);
        modalCloseButton.addEventListener('click', closeProfileModal);
        modalSaveButton.addEventListener('click', handleProfileSave);
        
        // --- NEW: Edit/Delete Modal Listeners ---
        editModalCancelButton.addEventListener('click', closeEditModal);
        editModalSaveButton.addEventListener('click', saveEdit);
        confirmModalNoButton.addEventListener('click', closeConfirmModal);
        confirmModalYesButton.addEventListener('click', handleDelete);


        // Handle Enter/Shift+Enter for Confessions
        confessionInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); 
                confessionForm.requestSubmit(confessionButton);
            } else {
                updateTypingStatus(true); // User is typing
            }
        });

        // Handle Enter/Shift+Enter for Chat
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); 
                chatForm.requestSubmit(chatButton);
            } else {
                updateTypingStatus(true); // User is typing
            }
        });

        // Start the application
        initFirebase();
    </script>

</body>

</html>