<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KIIT Confessions // TRON</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font 'Inter' for readability -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <!-- Custom Styles for Tron Theme -->
    <style>
        /* Base styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a1a;
            /* Dark blue/black */
            color: #00e5ff;
            /* Neon blue */
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff;
        }

        /* Helper for glowing effect */
        .glow {
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff, 0 0 15px #00e5ff;
        }

        /* Neon Borders */
        .neon-border {
            border: 2px solid #00e5ff;
            box-shadow: 0 0 10px #00e5ff, 0 0 15px #00e5ff inset;
            border-radius: 0.5rem;
            /* 8px */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #00e5ff;
            border-radius: 4px;
            box-shadow: 0 0 5px #00e5ff;
        }

        /* Textarea and Button Styling */
        textarea,
        button {
            font-family: 'Inter', sans-serif;
            background-color: rgba(0, 229, 255, 0.05);
            /* Faint blue */
            border: 1px solid #00e5ff;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff;
            transition: all 0.3s ease;
        }

        textarea::placeholder {
            color: #00e5ff;
            opacity: 0.5;
        }

        textarea:focus {
            outline: none;
            background-color: rgba(0, 229, 255, 0.1);
            box-shadow: 0 0 10px #00e5ff;
        }

        button:hover {
            background-color: #00e5ff;
            color: #0a0a1a;
            text-shadow: none;
            box-shadow: 0 0 15px #00e5ff;
        }

        /* Style for text input */
        input[type="text"] {
            font-family: 'Inter', sans-serif;
            background-color: rgba(0, 229, 255, 0.05);
            /* Faint blue */
            border: 1px solid #00e5ff;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff;
            transition: all 0.3s ease;
        }

        input[type="text"]::placeholder {
            color: #00e5ff;
            opacity: 0.5;
        }

        input[type="text"]:focus {
            outline: none;
            background-color: rgba(0, 229, 255, 0.1);
            box-shadow: 0 0 10px #00e5ff;
        }


        /* Feed container */
        #feedContainer {
            background-color: rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        /* Individual message bubbles */
        .message-bubble {
            background-color: rgba(30, 30, 50, 0.7);
            /* Dark grey-blue */
            border: 1px solid #007a8a;
            /* Darker cyan */
            text-shadow: 0 0 3px #00e5ff;
            word-wrap: break-word;
            /* Ensure long words break */
            white-space: pre-wrap;
            /* Respect newlines */
            padding: 0.5rem 0.75rem;
            /* Tighter padding */
            transition: background-color 0.2s;
        }

        /* "My" message bubbles */
        .my-message {
            background-color: rgba(0, 50, 100, 0.8);
            /* Dark blue */
            border: 1px solid #00e5ff;
            /* Bright cyan */
            align-self: flex-end;
        }
        
        /* NEW: Selected message styling */
        .selected-message {
            background-color: rgba(0, 229, 255, 0.2) !important;
            border-color: #00e5ff !important;
        }

        /* Timestamp styling */
        .timestamp {
            font-size: 0.65rem;
            /* 10px */
            color: #00e5ff;
            opacity: 0.6;
            text-shadow: none;
            margin-top: 2px;
            /* Tighter margin */
            display: flex; /* NEW: for edit/delete buttons */
            justify-content: flex-end; /* NEW */
            align-items: center; /* NEW */
            gap: 4px; /* NEW */
        }

        /* REMOVED: Edit/Delete button styling */
        /* .edit-btn, .delete-btn { ... } */

        /* NEW: Kebab button styling */
        .kebab-btn {
            background: none;
            border: none;
            padding: 0 4px;
            margin: 0;
            color: #00e5ff;
            opacity: 0.5;
            cursor: pointer;
            border-radius: 4px;
        }
        .kebab-btn:hover {
            opacity: 1;
            background-color: rgba(0, 229, 255, 0.1);
        }

        /* NEW: Edited marker styling */
        .edited-marker {
            font-size: 0.6rem;
            opacity: 0.5;
            margin-right: 4px;
        }


        /* Navigation styling */
        .nav-item {
            cursor: pointer;
            padding: 8px 16px;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .nav-item.active,
        .nav-item:hover {
            opacity: 1;
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff;
            border-bottom-color: #00e5ff;
        }

        /* Profile picture in chat */
        .chat-pfp {
            width: 32px;
            /* Smaller */
            height: 32px;
            /* Smaller */
            border-radius: 50%;
            border: 2px solid #00e5ff;
            object-fit: cover;
            flex-shrink: 0;
        }

        /* Typing indicator styling */
        #typingIndicator {
            height: 1.5rem;
            /* 24px */
            font-size: 0.875rem;
            /* 14px */
            color: #00e5ff;
            opacity: 0.7;
            text-shadow: 0 0 5px #00e5ff;
            transition: opacity 0.3s ease;
        }

        /* NEW: Custom Context Menu */
        #contextMenu {
            position: fixed;
            z-index: 1000;
            background-color: #0a0a1a;
            border: 2px solid #00e5ff;
            box-shadow: 0 0 10px #00e5ff;
            border-radius: 0.5rem;
            padding: 0.5rem 0;
            min-width: 150px;
        }
        #contextMenu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        #contextMenu li {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        #contextMenu li:hover {
            background-color: #00e5ff;
            color: #0a0a1a;
            text-shadow: none;
        }
        #contextMenu li.separator {
            height: 1px;
            background-color: #00e5ff;
            opacity: 0.3;
            margin: 0.25rem 0;
            padding: 0;
        }

        /* NEW: Selection Bar */
        #selectionBar {
            background-color: rgba(0, 50, 100, 0.9);
            border-top: 2px solid #00e5ff;
            padding: 0.5rem 1rem;
        }

    </style>
</head>

<body class="flex flex-col h-screen bg-[#0a0a1a]">

    <!-- Header -->
    <header class="flex justify-between items-center p-2 sm:p-4 border-b-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20 gap-2 sm:gap-4">
        <!-- Left Side: Title -->
        <h1 class="text-xl sm:text-3xl font-bold glow">KIIT CONFESSIONS</h1>

        <!-- Right Side: Nav and Profile -->
        <div class="flex items-center gap-2 sm:gap-4">
            <nav class="flex text-base sm:text-lg gap-2 sm:gap-4">
                <div id="navConfessions" class="nav-item">CONFESSIONS</div>
                <div id="navChat" class="nav-item active">CHAT</div>
            </nav>
            <button id="profileButton" class="p-2 rounded-full hover:bg-gray-700 transition" title="Edit Profile">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col overflow-hidden"> <!-- Full-height chat area -->
        <!-- Feed Container -->
        <div id="feedContainer" class="flex-1 flex flex-col p-2 sm:p-4 gap-2 overflow-y-auto"> <!-- Removed neon-border, added padding -->
            <!-- Messages will be injected here -->
            <div id="loading" class="text-center p-4">CONNECTING TO GRID...</div>
        </div>

        <!-- NEW: Selection Bar -->
        <div id="selectionBar" class="hidden flex justify-between items-center">
            <span id="selectionCount" class="text-lg">0 selected</span>
            <div class="flex gap-4">
                <button id="selectionCancel" class="font-bold">CANCEL</button>
                <button id="selectionDelete" class="font-bold text-red-400">DELETE</button>
            </div>
        </div>

        <!-- Typing Indicator -->
        <div id="typingIndicator" class="px-4 h-6 text-sm opacity-70">&nbsp;</div>

        <!-- Input Forms (one for each page) -->
        <form id="confessionForm" class="hidden gap-3 p-2 sm:p-4 border-t-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20">
            <textarea id="confessionInput" rows="2"
                class="flex-1 p-3 rounded-lg resize-none focus:outline-none"
                placeholder="TYPE YOUR CONFESSION... (SHIFT+ENTER FOR NEW LINE)" required></textarea>
            <button id="confessionButton" type="submit"
                class="px-6 py-2 rounded-lg font-bold">CONFESS</button>
        </form>

        <form id="chatForm" class="flex gap-3 p-2 sm:p-4 border-t-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20">
            <textarea id="chatInput" rows="2" class="flex-1 p-3 rounded-lg resize-none focus:outline-none"
                placeholder="TYPE YOUR MESSAGE... (SHIFT+ENTER FOR NEW LINE)" required></textarea>
            <button id="chatButton" type="submit" class="px-6 py-2 rounded-lg font-bold">SEND</button>
        </form>
    </main>


    <!-- Profile Modal -->
    <div id="profileModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-2xl font-bold glow">EDIT PROFILE</h2>

            <!-- Username Input -->
            <div class="flex flex-col gap-2">
                <label for="modalUsernameInput" class="text-sm opacity-70">Username</label>
                <input type="text" id="modalUsernameInput" placeholder="SET YOUR USERNAME..."
                    class="w-full p-3 rounded-lg focus:outline-none" />
            </div>

            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="modalCloseButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="modalSaveButton" class="flex-1 px-6 py-2 rounded-lg font-bold">SAVE</button>
            </div>
        </div>
    </div>

    <!-- Edit Message Modal -->
    <div id="editModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-2xl font-bold glow">EDIT MESSAGE</h2>
            
            <textarea id="modalEditTextArea" rows="4" class="w-full p-3 rounded-lg resize-none focus:outline-none"></textarea>

            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="editModalCancelButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="editModalSaveButton" class="flex-1 px-6 py-2 rounded-lg font-bold">SAVE</button>
            </div>
        </div>
    </div>

    <!-- Confirm Delete Modal -->
    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-xl font-bold glow">DELETE MESSAGE</h2>
            <p id="confirmModalText" class="text-base opacity-90">Are you sure you want to permanently delete this message?</p>
            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="confirmModalNoButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="confirmModalYesButton" class="flex-1 px-6 py-2 rounded-lg font-bold bg-red-800 border-red-500 hover:bg-red-600">DELETE</button>
            </div>
        </div>
    </div>

    <!-- NEW: Custom Context Menu (now used as dropdown) -->
    <div id="contextMenu" class="hidden">
        <ul>
            <li id="menuEdit">Edit</li>
            <li id="menuDelete">Delete</li>
            <li class="separator"></li>
            <li id="menuSelect">Select</li>
        </ul>
    </div>


    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import {
            initializeApp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            signInAnonymously
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            onSnapshot,
            query,
            serverTimestamp,
            doc,
            setDoc,
            getDoc,
            orderBy,
            updateDoc,
            deleteDoc,
            writeBatch // --- NEW
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyCtFOOGfjbeLM-bAT5i2J601w9_95MQlxs",
            authDomain: "kiit-confessions.firebaseapp.com",
            projectId: "kiit-confessions",
            storageBucket: "kiit-confessions.firebasestorage.app",
            messagingSenderId: "844059847809",
            appId: "1:844059847809:web:98a8a39a3a33c2dd7d3180",
            measurementId: "G-2JRL8TMMV7"
        };


        // --- DOM Elements ---
        const feedContainer = document.getElementById('feedContainer');
        const loading = document.getElementById('loading');
        const navConfessions = document.getElementById('navConfessions');
        const navChat = document.getElementById('navChat');
        const confessionForm = document.getElementById('confessionForm');
        const confessionInput = document.getElementById('confessionInput');
        const confessionButton = document.getElementById('confessionButton');
        const chatForm = document.getElementById('chatForm');
        const chatInput = document.getElementById('chatInput');
        const chatButton = document.getElementById('chatButton');
        const typingIndicator = document.getElementById('typingIndicator');

        // --- Modal DOM Elements ---
        const profileButton = document.getElementById('profileButton');
        const profileModal = document.getElementById('profileModal');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const modalSaveButton = document.getElementById('modalSaveButton');
        const modalUsernameInput = document.getElementById('modalUsernameInput');

        // --- Edit/Delete Modal Elements ---
        const editModal = document.getElementById('editModal');
        const modalEditTextArea = document.getElementById('modalEditTextArea');
        const editModalCancelButton = document.getElementById('editModalCancelButton');
        const editModalSaveButton = document.getElementById('editModalSaveButton');

        const confirmModal = document.getElementById('confirmModal');
        const confirmModalText = document.getElementById('confirmModalText');
        const confirmModalNoButton = document.getElementById('confirmModalNoButton');
        const confirmModalYesButton = document.getElementById('confirmModalYesButton');

        // --- NEW: Context Menu & Selection Bar Elements ---
        const contextMenu = document.getElementById('contextMenu');
        const menuEdit = document.getElementById('menuEdit');
        const menuDelete = document.getElementById('menuDelete');
        const menuSelect = document.getElementById('menuSelect');

        const selectionBar = document.getElementById('selectionBar');
        const selectionCount = document.getElementById('selectionCount');
        const selectionCancel = document.getElementById('selectionCancel');
        const selectionDelete = document.getElementById('selectionDelete');

        // --- App State ---
        let db;
        let auth;
        let currentUserId = null;
        let currentUsername = 'Anonymous';
        let currentProfilePhotoURL = null;
        let userProfiles = {}; 
        let confessionsCollection;
        let chatCollection;
        let typingStatusCollection;
        let unsubscribeConfessions = () => {};
        let unsubscribeChat = () => {};
        let unsubscribeUserProfiles = () => {};
        let unsubscribeTypingStatus = () => {};
        let currentPage = 'chat';
        let typingTimeout = null;
        
        // --- Edit/Delete State ---
        let docToEditId = null;
        let collectionToEdit = null;
        let deleteCallback = null; 

        // --- NEW: Selection State ---
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let currentContextMenuData = null; // Store dataset of right-clicked message

        // --- Firebase Initialization ---
        async function initFirebase() {
            try {
                if (firebaseConfig.apiKey === "AIzaSyCtFOOGfjbeLM-bAT5i2J601w9_95MQlxs") {
                    console.log("Firebase config loaded.");
                } else {
                    throw new Error("Firebase configuration is missing or incorrect.");
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                const userCredential = await signInAnonymously(auth);
                currentUserId = userCredential.user.uid;
                console.log("Firebase initialized and user signed in:", currentUserId);

                listenForUserProfiles();
                await loadUserProfile(); 

                confessionsCollection = collection(db, 'confessions');
                chatCollection = collection(db, 'chat');
                typingStatusCollection = collection(db, 'typingStatus');

                showPage(currentPage); // This will be 'chat'

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                loading.textContent = "Error: Could not connect to the grid. Refresh page.";
                if (error.message.includes("api-key-not-valid")) {
                    loading.textContent = "Error: Firebase API Key is not valid. Check console.";
                }
            }
        }

        // --- User Profile Functions ---
        function listenForUserProfiles() {
            const usersCollection = collection(db, 'users');
            unsubscribeUserProfiles = onSnapshot(usersCollection, (snapshot) => {
                snapshot.docs.forEach(doc => {
                    userProfiles[doc.id] = doc.data();
                });
                console.log("User profiles cache updated:", userProfiles);
                if (currentPage === 'chat') {
                    listenForChat(true); 
                } else {
                    listenForConfessions(true);
                }
            });
        }
        
        async function loadUserProfile() {
            if (!db || !currentUserId) return;
            const userDocRef = doc(db, 'users', currentUserId);
            const userDoc = await getDoc(userDocRef);

            if (userDoc.exists()) {
                const data = userDoc.data();
                currentUsername = data.username || 'Anonymous';
                currentProfilePhotoURL = data.profilePhotoURL || null;
            } else {
                currentUsername = 'Anonymous';
                currentProfilePhotoURL = null;
            }
            modalUsernameInput.value = currentUsername === 'Anonymous' ? '' : currentUsername;
        }

        async function handleProfileSave() {
            if (!db || !currentUserId) return;
            modalSaveButton.textContent = "SAVING...";
            modalSaveButton.disabled = true;
            const newUsername = modalUsernameInput.value.trim() || 'Anonymous';
            let newProfilePhotoURL = null;
            if (newUsername && newUsername !== 'Anonymous') {
                const firstLetter = newUsername.charAt(0).toUpperCase();
                newProfilePhotoURL = `https://placehold.co/32x32/0a0a1a/00e5ff?text=${firstLetter}`; 
            } else {
                newProfilePhotoURL = `https://placehold.co/32x32/00e5ff/0a0a1a?text=?`;
            }
            
            try {
                const userDocRef = doc(db, 'users', currentUserId);
                await setDoc(userDocRef, {
                    username: newUsername,
                    profilePhotoURL: newProfilePhotoURL 
                }, { merge: true });
                currentUsername = newUsername;
                currentProfilePhotoURL = newProfilePhotoURL;
                closeProfileModal();
            } catch (error) {
                console.error("Error saving profile: ", error);
            } finally {
                modalSaveButton.textContent = "SAVE";
                modalSaveButton.disabled = false;
            }
        }

        // --- Modal Controls ---
        function openProfileModal() {
            modalUsernameInput.value = currentUsername === 'Anonymous' ? '' : currentUsername;
            profileModal.classList.remove('hidden');
        }

        function closeProfileModal() {
            profileModal.classList.add('hidden');
        }

        // --- Edit/Delete Modal Controls & Logic ---
        function showEditModal(docId, collectionName, currentText) {
            docToEditId = docId;
            collectionToEdit = collectionName;
            modalEditTextArea.value = currentText;
            editModal.classList.remove('hidden');
        }
        
        function closeEditModal() {
            editModal.classList.add('hidden');
            docToEditId = null;
            collectionToEdit = null;
        }

        async function saveEdit() {
            const newText = modalEditTextArea.value.trim();
            if (newText && docToEditId && collectionToEdit) {
                editModalSaveButton.textContent = "SAVING...";
                editModalSaveButton.disabled = true;
                try {
                    const docRef = doc(db, collectionToEdit, docToEditId);
                    await updateDoc(docRef, {
                        text: newText,
                        edited: true 
                    });
                    closeEditModal();
                } catch (error) {
                    console.error("Error updating document:", error);
                    alert("Error: Could not save edit. The 5-minute edit window may have expired.");
                }
                editModalSaveButton.textContent = "SAVE";
                editModalSaveButton.disabled = false;
            }
        }

        function showConfirmModal(callback) {
            deleteCallback = callback; 
            confirmModal.classList.remove('hidden');
        }
        
        function closeConfirmModal() {
            confirmModal.classList.add('hidden');
            deleteCallback = null;
        }
        
        async function handleDelete() {
            if (deleteCallback) {
                confirmModalYesButton.textContent = "DELETING...";
                confirmModalYesButton.disabled = true;
                try {
                    await deleteCallback(); 
                } catch (error) {
                    console.error("Error deleting document:", error);
                    alert("Error: Could not delete message.");
                }
                closeConfirmModal();
                confirmModalYesButton.textContent = "DELETE";
                confirmModalYesButton.disabled = false;
            }
        }
        
        // --- NEW: Dropdown Menu & Selection Logic ---

        function showDropdownMenu(event, data) {
            // This function now opens the menu relative to the clicked button
            event.stopPropagation(); // Stop click from bubbling up to document
            currentContextMenuData = data; // Store data from the bubble
            
            // Check for 5-min edit window
            const now = Date.now();
            const messageTime = parseInt(currentContextMenuData.timestamp, 10);
            const isEditable = (now - messageTime < 300000); // 5 mins in ms

            menuEdit.style.display = isEditable ? 'block' : 'none';

            // Position and show menu
            const rect = event.currentTarget.getBoundingClientRect();
            contextMenu.style.top = `${rect.bottom + 2}px`; // Position below button
            
            // Right-align the menu
            const menuWidth = contextMenu.offsetWidth || 150;
            contextMenu.style.left = `${rect.right - menuWidth}px`; 
            
            contextMenu.classList.remove('hidden');
        }

        function hideDropdownMenu() {
            contextMenu.classList.add('hidden');
            currentContextMenuData = null;
        }
        
        function handleMessageClick(bubble) {
            if (!isSelectionMode) return;
            
            const docId = bubble.dataset.id;
            const isMine = bubble.dataset.isMine === 'true';

            if (!isMine) return; // Can only select own messages

            if (selectedMessages.has(docId)) {
                selectedMessages.delete(docId);
                bubble.classList.remove('selected-message');
            } else {
                selectedMessages.add(docId);
                bubble.classList.add('selected-message');
            }
            
            updateSelectionBar();
        }

        function enterSelectionMode() {
            isSelectionMode = true;
            selectionBar.classList.remove('hidden');
            
            // Add the right-clicked message to selection
            if (currentContextMenuData) {
                const docId = currentContextMenuData.id;
                selectedMessages.add(docId);
                const bubble = document.querySelector(`.message-bubble[data-id="${docId}"]`);
                if (bubble) {
                    bubble.classList.add('selected-message');
                }
            }
            updateSelectionBar();
        }
        
        function exitSelectionMode() {
            isSelectionMode = false;
            selectionBar.classList.add('hidden');
            selectedMessages.clear();
            
            // Remove all selected-message classes
            document.querySelectorAll('.selected-message').forEach(el => {
                el.classList.remove('selected-message');
            });
        }
        
        function updateSelectionBar() {
            const count = selectedMessages.size;
            selectionCount.textContent = `${count} selected`;
            
            if (count === 0) {
                exitSelectionMode();
            }
        }
        
        async function handleMultiDelete() {
            const count = selectedMessages.size;
            if (count === 0) return;
            
            // Show a custom confirmation
            confirmModalText.textContent = `Are you sure you want to permanently delete these ${count} messages?`;
            showConfirmModal(async () => {
                const batch = writeBatch(db);
                selectedMessages.forEach(docId => {
                    const docRef = doc(db, currentPage, docId);
                    batch.delete(docRef);
                });
                
                await batch.commit();
                exitSelectionMode();
                confirmModalText.textContent = "Are you sure you want to permanently delete this message?"; // Reset modal text
            });
        }

        // --- Page Navigation ---
        function showPage(page) {
            currentPage = page;
            exitSelectionMode(); // Exit selection mode on page change
            
            unsubscribeConfessions();
            unsubscribeChat();
            unsubscribeTypingStatus();
            typingIndicator.innerHTML = '&nbsp;'; 

            if (page === 'confessions') {
                navConfessions.classList.add('active');
                navChat.classList.remove('active');
                confessionForm.classList.remove('hidden');
                confessionForm.classList.add('flex');
                chatForm.classList.add('hidden');
                chatForm.classList.remove('flex');
                typingIndicator.classList.add('hidden'); 
                listenForConfessions();
            } else {
                navChat.classList.add('active');
                navConfessions.classList.remove('active');
                chatForm.classList.remove('hidden');
                chatForm.classList.add('flex');
                confessionForm.classList.add('hidden');
                confessionForm.classList.remove('flex');
                typingIndicator.classList.remove('hidden'); 
                listenForChat();
                listenForTyping();
            }
        }

        // --- Real-time Data Listeners ---
        let lastConfessionDocs = [];
        let lastChatDocs = [];

        function listenForConfessions(isRerender = false) { 
            if (isRerender) {
                renderFeed(lastConfessionDocs, 'confessions');
                return;
            }
            unsubscribeChat(); 
            feedContainer.innerHTML =
                '<div id="loading" class="text-center p-4">LOADING CONFESSIONS...</div>';
        
            const q = query(confessionsCollection, orderBy("timestamp", "asc"));
            unsubscribeConfessions = onSnapshot(q, (snapshot) => {
                lastConfessionDocs = snapshot.docs; 
                renderFeed(lastConfessionDocs, 'confessions');
            }, (error) => {
                console.error("Error listening to confessions:", error);
                loading.textContent = "Error loading confessions.";
            });
        }

        function listenForChat(isRerender = false) {
            if (isRerender) {
                renderFeed(lastChatDocs, 'chat');
                return;
            }
            unsubscribeConfessions(); 
            feedContainer.innerHTML =
                '<div id="loading" class="text-center p-4">LOADING CHAT...</div>';

            const q = query(chatCollection, orderBy("timestamp", "asc"));
            unsubscribeChat = onSnapshot(q, (snapshot) => {
                lastChatDocs = snapshot.docs; 
                renderFeed(lastChatDocs, 'chat');
            }, (error) => {
                console.error("Error listening to chat:", error);
                loading.textContent = "Error loading chat.";
            });
        }

        // --- Typing Indicator Logic ---
        function listenForTyping() {
            unsubscribeTypingStatus = onSnapshot(typingStatusCollection, (snapshot) => {
                const now = Date.now();
                const typingUsers = [];
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const userId = doc.id;
                    if (data.isTyping && userId !== currentUserId && (now - data.timestamp < 5000)) {
                        const username = userProfiles[userId]?.username || 'Someone';
                        typingUsers.push(username);
                    }
                });
                if (typingUsers.length === 0) {
                    typingIndicator.innerHTML = '&nbsp;'; 
                } else if (typingUsers.length === 1) {
                    typingIndicator.textContent = `${typingUsers[0]} is typing...`;
                } else if (typingUsers.length === 2) {
                    typingIndicator.textContent = `${typingUsers[0]} and ${typingUsers[1]} are typing...`;
                } else {
                    typingIndicator.textContent = 'Several users are typing...';
                }
            });
        }

        async function updateTypingStatus(isTyping) {
            if (!db || !currentUserId) return;
            if (typingTimeout) {
                clearTimeout(typingTimeout);
                typingTimeout = null;
            }
            const typingDocRef = doc(db, 'typingStatus', currentUserId);
            if (isTyping) {
                await setDoc(typingDocRef, {
                    isTyping: true,
                    timestamp: Date.now()
                });
                typingTimeout = setTimeout(() => {
                    updateTypingStatus(false);
                }, 3000); 
            } else {
                await setDoc(typingDocRef, {
                    isTyping: false,
                    timestamp: Date.now()
                });
            }
        }

        // --- Helper Function to Format Timestamp ---
        function formatTimestamp(firebaseTimestamp) {
            if (!firebaseTimestamp) return '...';
            const date = firebaseTimestamp.toDate();
            return date.toLocaleString([], { 
                dateStyle: 'short', 
                timeStyle: 'short' 
            });
        }

        // --- Render Function (UPDATED) ---
        function renderFeed(docs, type) {
            feedContainer.innerHTML = ''; 
            if (docs.length === 0) {
                const loadingEl = document.createElement('div');
                loadingEl.id = 'loading';
                loadingEl.className = 'text-center p-4';
                loadingEl.textContent = `NO ${type.toUpperCase()} YET. BE THE FIRST!`;
                feedContainer.appendChild(loadingEl);
                return;
            }

            let lastUserId = null; 

            docs.forEach(docInstance => {
                const data = docInstance.data();
                const text = data.text || '...';
                const time = formatTimestamp(data.timestamp);
                const docUserId = data.userId;
                
                const profile = userProfiles[docUserId] || {};
                const username = profile.username || 'Anonymous';
                const photoURL = profile.profilePhotoURL || `https://placehold.co/32x32/00e5ff/0a0a1a?text=${username.charAt(0).toUpperCase() || '?'}`;

                const isMine = currentUserId && docUserId === currentUserId;
                const isConsecutive = (docUserId && docUserId === lastUserId);
                lastUserId = docUserId; 

                const alignWrapper = document.createElement('div');
                alignWrapper.className = `flex w-full ${isMine ? 'justify-end' : 'justify-start'}`;

                const bubble = document.createElement('div');
                bubble.className = `message-bubble rounded-lg max-w-xs sm:max-w-md md:max-w-lg ${isMine ? 'my-message' : ''} ${isConsecutive ? 'mt-0.5' : 'mt-2'}`; 
                
                // --- NEW: Add dataset attributes for context menu ---
                bubble.dataset.id = docInstance.id;
                bubble.dataset.text = text;
                bubble.dataset.isMine = isMine;
                bubble.dataset.timestamp = data.timestamp ? data.timestamp.toMillis() : 0;
                
                // --- NEW: Add selected class if in selection set ---
                if (isSelectionMode && selectedMessages.has(docInstance.id)) {
                    bubble.classList.add('selected-message');
                }

                if (!isConsecutive) {
                    const headerElement = document.createElement('div');
                    headerElement.className = `flex items-center gap-1.5 mb-1 ${isMine ? 'justify-end' : ''}`; 
                    const imgElement = document.createElement('img');
                    imgElement.src = photoURL;
                    imgElement.className = `chat-pfp ${isMine ? 'order-2' : 'order-1'}`; 
                    const usernameElement = document.createElement('div');
                    usernameElement.className = `font-bold text-sm opacity-70 ${isMine ? 'order-1 text-right' : 'order-2 text-left'}`;
                    usernameElement.textContent = username;
                    headerElement.appendChild(imgElement);
                    headerElement.appendChild(usernameElement);
                    bubble.appendChild(headerElement);
                }

                const textElement = document.createElement('p');
                textElement.className = `${isMine ? 'text-right' : 'text-left'}`;
                textElement.textContent = text;
                bubble.appendChild(textElement);

                const timeElement = document.createElement('div');
                timeElement.className = 'timestamp text-right';
                
                if (data.edited) {
                    const editedMarker = document.createElement('span');
                    editedMarker.className = 'edited-marker';
                    editedMarker.textContent = '(edited)';
                    timeElement.appendChild(editedMarker);
                }
                
                const timeText = document.createElement('span');
                timeText.textContent = time;
                timeElement.appendChild(timeText);

                // --- UPDATED: Add Kebab Menu Button ---
                if (isMine) {
                    const kebabBtn = document.createElement('button');
                    kebabBtn.className = 'kebab-btn';
                    // SVG for three vertical dots
                    kebabBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                    </svg>`;
                    
                    kebabBtn.addEventListener('click', (e) => {
                        showDropdownMenu(e, bubble.dataset);
                    });
                    
                    timeElement.appendChild(kebabBtn);
                }

                bubble.appendChild(timeElement);
                alignWrapper.appendChild(bubble);
                feedContainer.appendChild(alignWrapper);
            });

            // Auto-scroll to bottom
            if (!isSelectionMode) { // Don't auto-scroll when selecting
                feedContainer.scrollTop = feedContainer.scrollHeight;
            }
        }

        // --- Form Submission ---
        async function postConfession(e) {
            e.preventDefault();
            const text = confessionInput.value.trim();
            if (text && db) {
                try {
                    await addDoc(confessionsCollection, {
                        text: text,
                        timestamp: serverTimestamp(),
                        userId: currentUserId 
                    });
                    confessionInput.value = '';
                    updateTypingStatus(false); 
                } catch (error) {
                    console.error("Error adding confession: ", error);
                }
            }
        }

        async function postChatMessage(e) {
            e.preventDefault();
            const text = chatInput.value.trim();
            if (text && db) {
                try {
                    await addDoc(chatCollection, {
                        text: text,
                        timestamp: serverTimestamp(),
                        userId: currentUserId
                    });
                    chatInput.value = '';
                    updateTypingStatus(false);
                } catch (error) { // <-- FIXED: Removed stray 'S' here
                    console.error("Error adding chat message: ", error);
                }
            }
        }

        // --- Event Listeners ---
        confessionForm.addEventListener('submit', postConfession);
        chatForm.addEventListener('submit', postChatMessage);
        navConfessions.addEventListener('click', () => showPage('confessions'));
        navChat.addEventListener('click', () => showPage('chat'));

        // --- Modal Event Listeners ---
        profileButton.addEventListener('click', openProfileModal);
        modalCloseButton.addEventListener('click', closeProfileModal);
        modalSaveButton.addEventListener('click', handleProfileSave);
        
        editModalCancelButton.addEventListener('click', closeEditModal);
        editModalSaveButton.addEventListener('click', saveEdit);
        confirmModalNoButton.addEventListener('click', closeConfirmModal);
        confirmModalYesButton.addEventListener('click', handleDelete);

        // --- UPDATED: Context Menu & Selection Listeners ---
        
        // REMOVED: feedContainer.addEventListener('contextmenu', ...)
        
        // Handle left-clicks on the feed (for selection mode)
        feedContainer.addEventListener('click', (e) => {
            if (!isSelectionMode) return;
            
            // Don't trigger selection if clicking the kebab button
            if (e.target.closest('.kebab-btn')) return; 

            const bubble = e.target.closest('.message-bubble');
            if (!bubble) return;
            
            e.preventDefault(); // Prevent any other click behavior
            handleMessageClick(bubble);
        });
        
        // Global click to hide dropdown menu
        document.addEventListener('click', (e) => {
            // Hide if click is not on the menu AND not on a kebab button
            if (!contextMenu.contains(e.target) && !e.target.closest('.kebab-btn')) {
                hideDropdownMenu();
            }
        }, true); // Use capture phase

        // Context menu button clicks (no change, they target the global menu)
        menuEdit.addEventListener('click', () => {
            if (currentContextMenuData) {
                showEditModal(currentContextMenuData.id, currentPage, currentContextMenuData.text);
            }
            hideDropdownMenu();
        });
        
        menuDelete.addEventListener('click', () => {
            if (currentContextMenuData) {
                showConfirmModal(async () => {
                    await deleteDoc(doc(db, currentPage, currentContextMenuData.id));
                });
            }
            hideDropdownMenu();
        });
        
        menuSelect.addEventListener('click', () => {
            enterSelectionMode();
            hideDropdownMenu(); // enterSelectionMode will add the first item
        });
        
        // Selection bar button clicks
        selectionCancel.addEventListener('click', exitSelectionMode);
        selectionDelete.addEventListener('click', handleMultiDelete);


        // Handle Enter/Shift+Enter for Confessions
        confessionInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); 
                confessionForm.requestSubmit(confessionButton);
            } else {
                updateTypingStatus(true); 
            }
        });

        // Handle Enter/Shift+Enter for Chat
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); 
                chatForm.requestSubmit(chatButton);
            } else {
                updateTypingStatus(true);
            }
        });

        // Start the application
        initFirebase();
    </script>

</body>

</html>