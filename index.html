<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konvo // Anonymous Chat</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font 'Inter' for readability -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <!-- Custom Styles for Tron Theme -->
    <style>
        /* Base styling */
        :root {
            /* This --vh variable will be set by JavaScript for a perfect mobile fit */
            --vh: 100vh; 
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a1a;
            /* Dark blue/black */
            color: #00e5ff;
            /* Neon blue */
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff;
            /* Set height using the JS variable for mobile, fallback to h-screen */
            height: 100vh; /* Fallback for browsers without JS */
            height: var(--vh);
        }
        
        /* --- NEW: Keyframe Animations --- */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        @keyframes fadeOutPoof {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.9);
            }
        }
        @keyframes flashGlow {
            0% { box-shadow: 0 0 10px #00e5ff, 0 0 15px #00e5ff inset; }
            50% { box-shadow: 0 0 25px #fff, 0 0 35px #00e5ff inset; }
            100% { box-shadow: 0 0 10px #00e5ff, 0 0 15px #00e5ff inset; }
        }
        @keyframes slideInUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }
        @keyframes slideOutDown {
            from { transform: translateY(0); }
            to { transform: translateY(100%); }
        }

        /* Animation utility classes */
        .animate-fadeInUp { animation: fadeInUp 0.3s ease-out; }
        .animate-slideInRight { animation: slideInRight 0.3s ease-out; }
        .animate-fadeOutPoof { animation: fadeOutPoof 0.3s ease-out; }
        .animate-flashGlow { animation: flashGlow 0.8s ease-out; }

        /* Modal base styles for animation */
        .modal-base {
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }
        .modal-hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none; /* Make unclickable when hidden */
        }
        .modal-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }


        /* Helper for glowing effect */
        .glow {
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff, 0 0 15px #00e5ff;
        }

        /* Neon Borders */
        .neon-border {
            border: 2px solid #00e5ff;
            box-shadow: 0 0 10px #00e5ff, 0 0 15px #00e5ff inset;
            border-radius: 0.5rem;
            /* 8px */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #00e5ff;
            border-radius: 4px;
            box-shadow: 0 0 5px #00e5ff;
        }

        /* Textarea and Button Styling */
        textarea,
        button {
            font-family: 'Inter', sans-serif;
            background-color: rgba(0, 229, 255, 0.05);
            /* Faint blue */
            border: 1px solid #00e5ff;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff;
            transition: all 0.3s ease;
        }

        textarea::placeholder {
            color: #00e5ff;
            opacity: 0.5;
        }

        textarea:focus {
            outline: none;
            background-color: rgba(0, 229, 255, 0.1);
            box-shadow: 0 0 10px #00e5ff;
        }

        button:hover {
            background-color: #00e5ff;
            color: #0a0a1a;
            text-shadow: none;
            box-shadow: 0 0 15px #00e5ff;
        }

        /* Style for text input */
        input[type="text"] {
            font-family: 'Inter', sans-serif;
            background-color: rgba(0, 229, 255, 0.05);
            /* Faint blue */
            border: 1px solid #00e5ff;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff;
            transition: all 0.3s ease;
        }

        input[type="text"]::placeholder {
            color: #00e5ff;
            opacity: 0.5;
        }

        input[type="text"]:focus {
            outline: none;
            background-color: rgba(0, 229, 255, 0.1);
            box-shadow: 0 0 10px #00e5ff;
        }


        /* Feed container */
        #feedContainer {
            background-color: rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        /* Individual message bubbles */
        .message-bubble {
            background-color: rgba(30, 30, 50, 0.7);
            /* Dark grey-blue */
            border: 1px solid #007a8a;
            /* Darker cyan */
            text-shadow: 0 0 3px #00e5ff;
            word-wrap: break-word;
            /* Ensure long words break */
            white-space: pre-wrap;
            /* Respect newlines */
            padding: 0.5rem 0.75rem;
            /* Tighter padding */
            transition: background-color 0.2s;
        }

        /* "My" message bubbles */
        .my-message {
            background-color: rgba(0, 50, 100, 0.8);
            /* Dark blue */
            border: 1px solid #00e5ff;
            /* Bright cyan */
            align-self: flex-end;
        }

        /* NEW: Selected message styling */
        .selected-message {
            background-color: rgba(0, 229, 255, 0.2) !important;
            border-color: #00e5ff !important;
        }

        /* Timestamp styling */
        .timestamp {
            font-size: 0.65rem;
            /* 10px */
            color: #00e5ff;
            opacity: 0.6;
            text-shadow: none;
            margin-top: 2px;
            /* Tighter margin */
            display: flex;
            /* NEW: for edit/delete buttons */
            justify-content: flex-end;
            /* NEW */
            align-items: center;
            /* NEW */
            gap: 4px;
            /* NEW */
        }

        /* NEW: Kebab button styling */
        .kebab-btn {
            background: none;
            border: none;
            padding: 0 4px;
            margin: 0;
            color: #00e5ff;
            opacity: 0.5;
            cursor: pointer;
            border-radius: 4px;
        }

        .kebab-btn:hover {
            opacity: 1;
            background-color: rgba(0, 229, 255, 0.1);
        }

        /* NEW: Edited marker styling */
        .edited-marker {
            font-size: 0.6rem;
            opacity: 0.5;
            margin-right: 4px;
        }


        /* Navigation styling */
        .nav-item {
            cursor: pointer;
            padding: 8px 16px;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .nav-item.active,
        .nav-item:hover {
            opacity: 1;
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff;
            border-bottom-color: #00e5ff;
        }

        /* Profile picture in chat */
        .chat-pfp {
            width: 32px;
            /* Smaller */
            height: 32px;
            /* Smaller */
            border-radius: 50%;
            border: 2px solid #00e5ff;
            object-fit: cover;
            flex-shrink: 0;
        }

        /* Typing indicator styling */
        #typingIndicator {
            height: 1.5rem;
            /* 24px */
            font-size: 0.875rem;
            /* 14px */
            color: #00e5ff;
            opacity: 0.7;
            text-shadow: 0 0 5px #00e5ff;
            transition: opacity 0.3s ease;
        }

        /* NEW: Custom Context Menu */
        #contextMenu {
            position: fixed;
            z-index: 1000;
            background-color: #0a0a1a;
            border: 2px solid #00e5ff;
            box-shadow: 0 0 10px #00e5ff;
            border-radius: 0.5rem;
            padding: 0.5rem 0;
            min-width: 150px;
            /* Animation for dropdown */
            transition: opacity 0.1s ease-out, transform 0.1s ease-out;
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }
        #contextMenu.menu-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }


        #contextMenu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #contextMenu li {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #contextMenu li:hover {
            background-color: #00e5ff;
            color: #0a0a1a;
            text-shadow: none;
        }

        #contextMenu li.separator {
            height: 1px;
            background-color: #00e5ff;
            opacity: 0.3;
            margin: 0.25rem 0;
            padding: 0;
        }

        /* NEW: Selection Bar */
        #selectionBar {
            background-color: rgba(0, 50, 100, 0.9);
            border-top: 2px solid #00e5ff;
            padding: 0.5rem 1rem;
            /* Animation for slide up/down */
            transition: transform 0.3s ease-out;
        }
        #selectionBar.bar-hidden {
            transform: translateY(100%);
        }
        #selectionBar.bar-visible {
            transform: translateY(0);
        }

    </style>
</head>

<!-- Use the new height class from JS -->
<body class="flex flex-col bg-[#0a0a1a]">

    <!-- Header -->
    <header class="flex justify-between items-center p-2 sm:p-4 border-b-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20 gap-2 sm:gap-4">
        <!-- Left Side: Title -->
        <h1 class="text-xl sm:text-3xl font-bold glow">KONVO</h1>

        <!-- Right Side: Nav and Profile -->
        <div class="flex items-center gap-2 sm:gap-4">
            <nav class="flex text-base sm:text-lg gap-2 sm:gap-4">
                <div id="navConfessions" class="nav-item">CONFESSIONS</div>
                <div id="navChat" class="nav-item active">CHAT</div>
            </nav>
            <button id="profileButton" class="p-2 rounded-full hover:bg-gray-700 transition" title="Edit Profile">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- Full-height chat area -->
        <!-- Feed Container -->
        <div id="feedContainer" class="flex-1 flex flex-col p-2 sm:p-4 gap-2 overflow-y-auto">
            <!-- Removed neon-border, added padding -->
            <!-- Messages will be injected here -->
            <div id="loading" class="text-center p-4">CONNECTING TO GRID...</div>
        </div>

        <!-- NEW: Selection Bar -->
        <div id="selectionBar" class="bar-hidden flex justify-between items-center">
            <span id="selectionCount" class="text-lg">0 selected</span>
            <div class="flex gap-4">
                <button id="selectionCancel" class="font-bold">CANCEL</button>
                <button id="selectionDelete" class="font-bold text-red-400">DELETE</button>
            </div>
        </div>

        <!-- Typing Indicator -->
        <div id="typingIndicator" class="px-4 h-6 text-sm opacity-70">&nbsp;</div>

        <!-- Input Forms (one for each page) -->
        <form id="confessionForm"
            class="hidden gap-3 p-2 sm:p-4 border-t-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20">
            <textarea id="confessionInput" rows="2"
                class="flex-1 p-3 rounded-lg resize-none focus:outline-none"
                placeholder="TYPE YOUR CONFESSION... (SHIFT+ENTER FOR NEW LINE)" required></textarea>
            <button id="confessionButton" type="submit"
                class="px-6 py-2 rounded-lg font-bold">CONFESS</button>
        </form>

        <form id="chatForm" class="flex gap-3 p-2 sm:p-4 border-t-2 border-[#00e5ff] shadow-lg shadow-[#00e5ff]/20">
            <textarea id="chatInput" rows="2" class="flex-1 p-3 rounded-lg resize-none focus:outline-none"
                placeholder="TYPE YOUR MESSAGE... (SHIFT+ENTER FOR NEW LINE)" required></textarea>
            <button id="chatButton" type="submit" class="px-6 py-2 rounded-lg font-bold">SEND</button>
        </form>
    </main>


    <!-- Profile Modal -->
    <div id="profileModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 modal-base modal-hidden">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-2xl font-bold glow">EDIT PROFILE</h2>

            <!-- Username Input -->
            <div class="flex flex-col gap-2">
                <label for="modalUsernameInput" class="text-sm opacity-70">Username</label>
                <input type="text" id="modalUsernameInput" placeholder="SET YOUR USERNAME..."
                    class="w-full p-3 rounded-lg focus:outline-none" />
            </div>

            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="modalCloseButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="modalSaveButton" class="flex-1 px-6 py-2 rounded-lg font-bold">SAVE</button>
            </div>
        </div>
    </div>

    <!-- Edit Message Modal -->
    <div id="editModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 modal-base modal-hidden">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-2xl font-bold glow">EDIT MESSAGE</h2>

            <textarea id="modalEditTextArea" rows="4"
                class="w-full p-3 rounded-lg resize-none focus:outline-none"></textarea>

            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="editModalCancelButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="editModalSaveButton" class="flex-1 px-6 py-2 rounded-lg font-bold">SAVE</button>
            </div>
        </div>
    </div>

    <!-- Confirm Delete Modal -->
    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 modal-base modal-hidden">
        <div class="bg-[#0a0a1a] p-6 rounded-lg neon-border w-full max-w-sm flex flex-col gap-4">
            <h2 class="text-xl font-bold glow">DELETE MESSAGE</h2>
            <p id="confirmModalText" class="text-base opacity-90">Are you sure you want to permanently delete this
                message?</p>
            <!-- Action Buttons -->
            <div class="flex gap-4 mt-4">
                <button id="confirmModalNoButton" class="flex-1 px-6 py-2 rounded-lg font-bold">CANCEL</button>
                <button id="confirmModalYesButton"
                    class="flex-1 px-6 py-2 rounded-lg font-bold bg-red-800 border-red-500 hover:bg-red-600">DELETE</button>
            </div>
        </div>
    </div>

    <!-- Custom Context Menu (now used as dropdown) -->
    <div id="contextMenu">
        <ul>
            <li id="menuEdit">Edit</li>
            <li id="menuDelete">Delete</li>
            <li class="separator"></li>
            <li id="menuSelect">Select</li>
        </ul>
    </div>

    <!-- NEW: Mobile Viewport Height Fix Script -->
    <script>
        function setViewportHeight() {
            // We execute this script early to prevent page jump
            let vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        setViewportHeight();
        // Update on resize/orientation change
        window.addEventListener('resize', setViewportHeight);
        window.addEventListener('orientationchange', setViewportHeight);
    </script>


    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import {
            initializeApp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            signInAnonymously
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            onSnapshot,
            query,
            serverTimestamp,
            doc,
            setDoc,
            getDoc,
            orderBy,
            updateDoc,
            deleteDoc,
            writeBatch // --- NEW
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyCtFOOGfjbeLM-bAT5i2J601w9_95MQlxs",
            authDomain: "kiit-confessions.firebaseapp.com",
            projectId: "kiit-confessions",
            storageBucket: "kiit-confessions.firebasestorage.app",
            messagingSenderId: "844059847809",
            appId: "1:844059847809:web:98a8a39a3a33c2dd7d3180",
            measurementId: "G-2JRL8TMMV7"
        };


        // --- DOM Elements ---
        const feedContainer = document.getElementById('feedContainer');
        const loading = document.getElementById('loading');
        const navConfessions = document.getElementById('navConfessions');
        const navChat = document.getElementById('navChat');
        const confessionForm = document.getElementById('confessionForm');
        const confessionInput = document.getElementById('confessionInput');
        const confessionButton = document.getElementById('confessionButton');
        const chatForm = document.getElementById('chatForm');
        const chatInput = document.getElementById('chatInput');
        const chatButton = document.getElementById('chatButton');
        const typingIndicator = document.getElementById('typingIndicator');

        // --- Modal DOM Elements ---
        const profileButton = document.getElementById('profileButton');
        const profileModal = document.getElementById('profileModal');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const modalSaveButton = document.getElementById('modalSaveButton');
        const modalUsernameInput = document.getElementById('modalUsernameInput');

        // --- Edit/Delete Modal Elements ---
        const editModal = document.getElementById('editModal');
        const modalEditTextArea = document.getElementById('modalEditTextArea');
        const editModalCancelButton = document.getElementById('editModalCancelButton');
        const editModalSaveButton = document.getElementById('editModalSaveButton');

        const confirmModal = document.getElementById('confirmModal');
        const confirmModalText = document.getElementById('confirmModalText');
        const confirmModalNoButton = document.getElementById('confirmModalNoButton');
        const confirmModalYesButton = document.getElementById('confirmModalYesButton');

        // --- Context Menu & Selection Bar Elements ---
        const contextMenu = document.getElementById('contextMenu');
        const menuEdit = document.getElementById('menuEdit');
        const menuDelete = document.getElementById('menuDelete');
        const menuSelect = document.getElementById('menuSelect');

        const selectionBar = document.getElementById('selectionBar');
        const selectionCount = document.getElementById('selectionCount');
        const selectionCancel = document.getElementById('selectionCancel');
        const selectionDelete = document.getElementById('selectionDelete');

        // --- App State ---
        let db;
        let auth;
        let currentUserId = null;
        let currentUsername = 'Anonymous';
        let currentProfilePhotoURL = null;
        let userProfiles = {};
        let confessionsCollection;
        let chatCollection;
        let typingStatusCollection;
        let unsubscribeConfessions = () => {};
        let unsubscribeChat = () => {};
        let unsubscribeUserProfiles = () => {};
        let unsubscribeTypingStatus = () => {};
        let currentPage = 'chat';
        let typingTimeout = null;

        // --- Edit/Delete State ---
        let docToEditId = null;
        let collectionToEdit = null;
        let deleteCallback = null;

        // --- Selection State ---
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let currentContextMenuData = null; // Store dataset of right-clicked message

        // --- Firebase Initialization ---
        async function initFirebase() {
            try {
                if (firebaseConfig.apiKey === "AIzaSyCtFOOGfjbeLM-bAT5i2J601w9_95MQlxs") {
                    console.log("Firebase config loaded.");
                } else {
                    throw new Error("Firebase configuration is missing or incorrect.");
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                const userCredential = await signInAnonymously(auth);
                currentUserId = userCredential.user.uid;
                console.log("Firebase initialized and user signed in:", currentUserId);

                listenForUserProfiles();
                await loadUserProfile();

                confessionsCollection = collection(db, 'confessions');
                chatCollection = collection(db, 'chat');
                typingStatusCollection = collection(db, 'typingStatus');

                showPage(currentPage); // This will be 'chat'

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                loading.textContent = "Error: Could not connect to the grid. Refresh page.";
                if (error.message.includes("api-key-not-valid")) {
                    loading.textContent = "Error: Firebase API Key is not valid. Check console.";
                }
            }
        }

        // --- User Profile Functions ---
        function listenForUserProfiles() {
            const usersCollection = collection(db, 'users');
            unsubscribeUserProfiles = onSnapshot(usersCollection, (snapshot) => {
                snapshot.docs.forEach(doc => {
                    userProfiles[doc.id] = doc.data();
                });
                console.log("User profiles cache updated:", userProfiles);
                if (currentPage === 'chat') {
                    listenForChat(true);
                } else {
                    listenForConfessions(true);
                }
            });
        }

        async function loadUserProfile() {
            if (!db || !currentUserId) return;
            const userDocRef = doc(db, 'users', currentUserId);
            const userDoc = await getDoc(userDocRef);

            if (userDoc.exists()) {
                const data = userDoc.data();
                currentUsername = data.username || 'Anonymous';
                currentProfilePhotoURL = data.profilePhotoURL || null;
            } else {
                currentUsername = 'Anonymous';
                currentProfilePhotoURL = null;
            }
            modalUsernameInput.value = currentUsername === 'Anonymous' ? '' : currentUsername;
        }

        async function handleProfileSave() {
            if (!db || !currentUserId) return;
            modalSaveButton.textContent = "SAVING...";
            modalSaveButton.disabled = true;
            const newUsername = modalUsernameInput.value.trim() || 'Anonymous';
            let newProfilePhotoURL = null;
            if (newUsername && newUsername !== 'Anonymous') {
                const firstLetter = newUsername.charAt(0).toUpperCase();
                newProfilePhotoURL = `https://placehold.co/32x32/0a0a1a/00e5ff?text=${firstLetter}`;
            } else {
                newProfilePhotoURL = `https://placehold.co/32x32/00e5ff/0a0a1a?text=?`;
            }

            try {
                const userDocRef = doc(db, 'users', currentUserId);
                await setDoc(userDocRef, {
                    username: newUsername,
                    profilePhotoURL: newProfilePhotoURL
                }, {
                    merge: true
                });
                currentUsername = newUsername;
                currentProfilePhotoURL = newProfilePhotoURL;
                closeProfileModal();
            } catch (error) {
                console.error("Error saving profile: ", error);
            } finally {
                modalSaveButton.textContent = "SAVE";
                modalSaveButton.disabled = false;
            }
        }

        // --- Modal Controls (UPDATED for Animations) ---
        function openProfileModal() {
            modalUsernameInput.value = currentUsername === 'Anonymous' ? '' : currentUsername;
            profileModal.classList.remove('modal-hidden');
            profileModal.classList.add('modal-visible');
        }

        function closeProfileModal() {
            profileModal.classList.remove('modal-visible');
            profileModal.classList.add('modal-hidden');
        }

        function showEditModal(docId, collectionName, currentText) {
            docToEditId = docId;
            collectionToEdit = collectionName;
            modalEditTextArea.value = currentText;
            editModal.classList.remove('modal-hidden');
            editModal.classList.add('modal-visible');
        }

        function closeEditModal() {
            editModal.classList.remove('modal-visible');
            editModal.classList.add('modal-hidden');
            docToEditId = null;
            collectionToEdit = null;
        }

        async function saveEdit() {
            const newText = modalEditTextArea.value.trim();
            if (newText && docToEditId && collectionToEdit) {
                editModalSaveButton.textContent = "SAVING...";
                editModalSaveButton.disabled = true;
                try {
                    const docRef = doc(db, collectionToEdit, docToEditId);
                    await updateDoc(docRef, {
                        text: newText,
                        edited: true
                    });
                    
                    // Flash the edited bubble
                    const bubble = document.querySelector(`.message-bubble[data-id="${docToEditId}"]`);
                    if (bubble) {
                        bubble.classList.add('animate-flashGlow');
                        setTimeout(() => bubble.classList.remove('animate-flashGlow'), 1000);
                    }
                    
                    closeEditModal();
                } catch (error) {
                    console.error("Error updating document:", error);
                    alert("Error: Could not save edit. The 5-minute edit window may have expired.");
                }
                editModalSaveButton.textContent = "SAVE";
                editModalSaveButton.disabled = false;
            }
        }

        function showConfirmModal(callback) {
            deleteCallback = callback;
            confirmModal.classList.remove('modal-hidden');
            confirmModal.classList.add('modal-visible');
        }

        function closeConfirmModal() {
            confirmModal.classList.remove('modal-visible');
            confirmModal.classList.add('modal-hidden');
            deleteCallback = null;
        }

        async function handleDelete() {
            if (deleteCallback) {
                confirmModalYesButton.textContent = "DELETING...";
                confirmModalYesButton.disabled = true;
                
                // Find the bubble *before* deleting
                const bubble = document.querySelector(`.message-bubble[data-id="${currentContextMenuData.id}"]`);
                
                try {
                    // Animate the bubble out
                    if (bubble) {
                        bubble.classList.add('animate-fadeOutPoof');
                        // Wait for animation to finish before deleting
                        await new Promise(r => setTimeout(r, 300)); 
                    }
                    await deleteCallback();
                } catch (error) {
                    console.error("DELETE FAILED:", error); 
                    alert("Error: Could not delete message. Check console (F12) for details.");
                    // If delete failed, remove the animation
                    if(bubble) bubble.classList.remove('animate-fadeOutPoof');
                }
                closeConfirmModal();
                confirmModalYesButton.textContent = "DELETE";
                confirmModalYesButton.disabled = false;
            }
        }

        // --- Dropdown Menu & Selection Logic (UPDATED for Animations) ---

        function showDropdownMenu(event, data) {
            event.stopPropagation(); 
            currentContextMenuData = data; 

            const now = Date.now();
            const messageTime = parseInt(currentContextMenuData.timestamp, 10);
            const isEditable = (now - messageTime < 300000); // 5 mins in ms

            menuEdit.style.display = isEditable ? 'block' : 'none';

            const rect = event.currentTarget.getBoundingClientRect();
            contextMenu.style.top = `${rect.bottom + 2}px`; 

            const menuWidth = contextMenu.offsetWidth || 150;
            contextMenu.style.left = `${rect.right - menuWidth}px`;
            
            contextMenu.classList.add('menu-visible'); // Use new animation class
        }

        function hideDropdownMenu() {
            contextMenu.classList.remove('menu-visible');
            currentContextMenuData = null;
        }

        function handleMessageClick(bubble) {
            if (!isSelectionMode) return;

            const docId = bubble.dataset.id;
            const isMine = bubble.dataset.isMine === 'true';

            if (!isMine) return; // Can only select own messages

            if (selectedMessages.has(docId)) {
                selectedMessages.delete(docId);
                bubble.classList.remove('selected-message');
            } else {
                selectedMessages.add(docId);
                bubble.classList.add('selected-message');
            }

            updateSelectionBar();
        }

        function enterSelectionMode() {
            isSelectionMode = true;
            selectionBar.classList.remove('bar-hidden'); // Animate in
            selectionBar.classList.add('bar-visible');
            chatForm.classList.add('hidden'); // Hide input forms
            confessionForm.classList.add('hidden');

            // Add the right-clicked message to selection
            if (currentContextMenuData) {
                const docId = currentContextMenuData.id;
                selectedMessages.add(docId);
                const bubble = document.querySelector(`.message-bubble[data-id="${docId}"]`);
                if (bubble) {
                    bubble.classList.add('selected-message');
                }
            }
            updateSelectionBar();
        }

        function exitSelectionMode() {
            isSelectionMode = false;
            selectionBar.classList.add('bar-hidden'); // Animate out
            selectionBar.classList.remove('bar-visible');
            selectedMessages.clear();
            
            if (currentPage === 'chat') {
                chatForm.classList.remove('hidden');
                chatForm.classList.add('flex');
            } else {
                confessionForm.classList.remove('hidden');
                confessionForm.classList.add('flex');
            }

            document.querySelectorAll('.selected-message').forEach(el => {
                el.classList.remove('selected-message');
            });
        }

        function updateSelectionBar() {
            const count = selectedMessages.size;
            selectionCount.textContent = `${count} selected`;

            if (count === 0) {
                exitSelectionMode();
            }
        }

        async function handleMultiDelete() {
            const count = selectedMessages.size;
            if (count === 0) return;

            confirmModalText.textContent = `Are you sure you want to permanently delete these ${count} messages?`;
            showConfirmModal(async () => {
                
                // Animate all bubbles out
                const deletePromises = [];
                selectedMessages.forEach(docId => {
                    const bubble = document.querySelector(`.message-bubble[data-id="${docId}"]`);
                    if (bubble) {
                        bubble.classList.add('animate-fadeOutPoof');
                        deletePromises.push(new Promise(r => setTimeout(r, 300)));
                    }
                });
                // Wait for all animations
                await Promise.all(deletePromises);

                // Now batch delete from DB
                const batch = writeBatch(db);
                selectedMessages.forEach(docId => {
                    const docRef = doc(db, currentPage, docId);
                    batch.delete(docRef);
                });

                await batch.commit();
                exitSelectionMode();
                confirmModalText.textContent = "Are you sure you want to permanently delete this message?";
            });
        }

        // --- Page Navigation ---
        function showPage(page) {
            currentPage = page;
            if(isSelectionMode) exitSelectionMode(); 

            unsubscribeConfessions();
            unsubscribeChat();
            unsubscribeTypingStatus();
            typingIndicator.innerHTML = '&nbsp;';

            if (page === 'confessions') {
                navConfessions.classList.add('active');
                navChat.classList.remove('active');
                if (!isSelectionMode) { 
                    confessionForm.classList.add('flex');
                    confessionForm.classList.remove('hidden');
                }
                chatForm.classList.add('hidden');
                chatForm.classList.remove('flex');
                typingIndicator.classList.add('hidden');
                listenForConfessions();
            } else {
                navChat.classList.add('active');
                navConfessions.classList.remove('active');
                 if (!isSelectionMode) { 
                    chatForm.classList.add('flex');
                    chatForm.classList.remove('hidden');
                }
                confessionForm.classList.add('hidden');
                confessionForm.classList.remove('flex');
                typingIndicator.classList.remove('hidden');
                listenForChat();
                listenForTyping();
            }
        }

        // --- Real-time Data Listeners ---
        let lastConfessionDocs = [];
        let lastChatDocs = [];

        function listenForConfessions(isRerender = false) {
            if (isRerender) {
                renderFeed(lastConfessionDocs, 'confessions');
                return;
            }
            unsubscribeChat();
            feedContainer.innerHTML =
                '<div id="loading" class="text-center p-4">LOADING CONFESSIONS...</div>';

            const q = query(confessionsCollection, orderBy("timestamp", "asc"));
            unsubscribeConfessions = onSnapshot(q, (snapshot) => {
                lastConfessionDocs = snapshot.docs;
                renderFeed(lastConfessionDocs, 'confessions');
            }, (error) => {
                console.error("Error listening to confessions:", error);
                loading.textContent = "Error loading confessions.";
            });
        }

        function listenForChat(isRerender = false) {
            if (isRerender) {
                renderFeed(lastChatDocs, 'chat');
                return;
            }
            unsubscribeConfessions();
            feedContainer.innerHTML =
                '<div id="loading" class="text-center p-4">LOADING CHAT...</div>';

            const q = query(chatCollection, orderBy("timestamp", "asc"));
            unsubscribeChat = onSnapshot(q, (snapshot) => {
                lastChatDocs = snapshot.docs;
                renderFeed(lastChatDocs, 'chat');
            }, (error) => {
                console.error("Error listening to chat:", error);
                loading.textContent = "Error loading chat.";
            });
        }

        // --- Typing Indicator Logic ---
        function listenForTyping() {
            unsubscribeTypingStatus = onSnapshot(typingStatusCollection, (snapshot) => {
                const now = Date.now();
                const typingUsers = [];
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const userId = doc.id;
                    if (data.isTyping && userId !== currentUserId && (now - data.timestamp < 5000)) {
                        const username = userProfiles[userId] ?.username || 'Someone';
                        typingUsers.push(username);
                    }
                });
                if (typingUsers.length === 0) {
                    typingIndicator.innerHTML = '&nbsp;';
                } else if (typingUsers.length === 1) {
                    typingIndicator.textContent = `${typingUsers[0]} is typing...`;
                } else if (typingUsers.length === 2) {
                    typingIndicator.textContent = `${typingUsers[0]} and ${typingUsers[1]} are typing...`;
                } else {
                    typingIndicator.textContent = 'Several users are typing...';
                }
            });
        }

        async function updateTypingStatus(isTyping) {
            if (!db || !currentUserId) return;
            if (typingTimeout) {
                clearTimeout(typingTimeout);
                typingTimeout = null;
            }
            const typingDocRef = doc(db, 'typingStatus', currentUserId);
            if (isTyping) {
                await setDoc(typingDocRef, {
                    isTyping: true,
                    timestamp: Date.now()
                });
                typingTimeout = setTimeout(() => {
                    updateTypingStatus(false);
                }, 3000);
            } else {
                await setDoc(typingDocRef, {
                    isTyping: false,
                    timestamp: Date.now()
                });
            }
        }

        // --- Helper Function to Format Timestamp ---
        function formatTimestamp(firebaseTimestamp) {
            if (!firebaseTimestamp) return '...';
            const date = firebaseTimestamp.toDate();
            return date.toLocaleString([], {
                dateStyle: 'short',
                timeStyle: 'short'
            });
        }

        // --- Render Function (UPDATED for Animations) ---
        function renderFeed(docs, type) {
            feedContainer.innerHTML = '';
            if (docs.length === 0) {
                const loadingEl = document.createElement('div');
                loadingEl.id = 'loading';
                loadingEl.className = 'text-center p-4';
                loadingEl.textContent = `NO ${type.toUpperCase()} YET. BE THE FIRST!`;
                feedContainer.appendChild(loadingEl);
                return;
            }

            let lastUserId = null;

            docs.forEach(docInstance => {
                const data = docInstance.data();
                const text = data.text || '...';
                const time = formatTimestamp(data.timestamp);
                const docUserId = data.userId;

                const profile = userProfiles[docUserId] || {};
                const username = profile.username || 'Anonymous';
                const photoURL = profile.profilePhotoURL || `https://placehold.co/32x32/00e5ff/0a0a1a?text=${username.charAt(0).toUpperCase() || '?'}`;

                const isMine = currentUserId && docUserId === currentUserId;
                const isConsecutive = (docUserId && docUserId === lastUserId);
                lastUserId = docUserId;

                const alignWrapper = document.createElement('div');
                alignWrapper.className = `flex w-full ${isMine ? 'justify-end' : 'justify-start'}`;

                const bubble = document.createElement('div');
                bubble.className = `message-bubble rounded-lg max-w-xs sm:max-w-md md:max-w-lg ${isMine ? 'my-message' : ''} ${isConsecutive ? 'mt-0.5' : 'mt-2'}`;

                bubble.dataset.id = docInstance.id;
                bubble.dataset.text = text;
                bubble.dataset.isMine = isMine;
                bubble.dataset.timestamp = data.timestamp ? data.timestamp.toMillis() : 0;

                if (isSelectionMode && selectedMessages.has(docInstance.id)) {
                    bubble.classList.add('selected-message');
                }

                // --- Animate new messages ---
                const isNew = (Date.now() - (data.timestamp ? data.timestamp.toMillis() : 0) < 3000); // 3 sec window
                if (isNew && !isSelectionMode) { 
                    alignWrapper.classList.add(isMine ? 'animate-slideInRight' : 'animate-fadeInUp');
                }

                if (!isConsecutive) {
                    const headerElement = document.createElement('div');
                    headerElement.className = `flex items-center gap-1.5 mb-1 ${isMine ? 'justify-end' : ''}`;
                    const imgElement = document.createElement('img');
                    imgElement.src = photoURL;
                    imgElement.className = `chat-pfp ${isMine ? 'order-2' : 'order-1'}`;
                    const usernameElement = document.createElement('div');
                    usernameElement.className = `font-bold text-sm opacity-70 ${isMine ? 'order-1 text-right' : 'order-2 text-left'}`;
                    usernameElement.textContent = username;
                    headerElement.appendChild(imgElement);
                    headerElement.appendChild(usernameElement);
                    bubble.appendChild(headerElement);
                }

                const textElement = document.createElement('p');
                textElement.className = `${isMine ? 'text-right' : 'text-left'}`;
                textElement.textContent = text;
                bubble.appendChild(textElement);

                const timeElement = document.createElement('div');
                timeElement.className = 'timestamp text-right';

                if (data.edited) {
                    const editedMarker = document.createElement('span');
                    editedMarker.className = 'edited-marker';
                    editedMarker.textContent = '(edited)';
                    timeElement.appendChild(editedMarker);
                }

                const timeText = document.createElement('span');
                timeText.textContent = time;
                timeElement.appendChild(timeText);

                if (isMine) {
                    const kebabBtn = document.createElement('button');
                    kebabBtn.className = 'kebab-btn';
                    kebabBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                    </svg>`;
                    kebabBtn.addEventListener('click', (e) => {
                        showDropdownMenu(e, bubble.dataset);
                    });
                    timeElement.appendChild(kebabBtn);
                }

                bubble.appendChild(timeElement);
                alignWrapper.appendChild(bubble);
                feedContainer.appendChild(alignWrapper);
            });

            // Auto-scroll to bottom
            if (!isSelectionMode) { // Don't auto-scroll when selecting
                feedContainer.scrollTop = feedContainer.scrollHeight;
            }
        }

        // --- Form Submission ---
        async function postConfession(e) {
            e.preventDefault();
            const text = confessionInput.value.trim();
            if (text && db) {
                try {
                    await addDoc(confessionsCollection, {
                        text: text,
                        timestamp: serverTimestamp(),
                        userId: currentUserId
                    });
                    confessionInput.value = '';
                    updateTypingStatus(false);
                } catch (error) {
                    console.error("Error adding confession: ", error);
                }
            }
        }

        async function postChatMessage(e) {
            e.preventDefault();
            const text = chatInput.value.trim();
            if (text && db) {
                try {
                    await addDoc(chatCollection, {
                        text: text,
                        timestamp: serverTimestamp(),
                        userId: currentUserId
                    });
                    chatInput.value = '';
                    updateTypingStatus(false);
                } catch (error) {
                    console.error("Error adding chat message: ", error);
                }
            }
        }

        // --- Event Listeners ---
        confessionForm.addEventListener('submit', postConfession);
        chatForm.addEventListener('submit', postChatMessage);
        navConfessions.addEventListener('click', () => showPage('confessions'));
        navChat.addEventListener('click', () => showPage('chat'));

        // --- Modal Event Listeners ---
        profileButton.addEventListener('click', openProfileModal);
        modalCloseButton.addEventListener('click', closeProfileModal);
        modalSaveButton.addEventListener('click', handleProfileSave);

        editModalCancelButton.addEventListener('click', closeEditModal);
        editModalSaveButton.addEventListener('click', saveEdit);
        confirmModalNoButton.addEventListener('click', closeConfirmModal);
        confirmModalYesButton.addEventListener('click', handleDelete);

        // --- Context Menu & Selection Listeners ---
        feedContainer.addEventListener('click', (e) => {
            if (!isSelectionMode) return;
            if (e.target.closest('.kebab-btn')) return;
            const bubble = e.target.closest('.message-bubble');
            if (!bubble) return;
            e.preventDefault(); 
            handleMessageClick(bubble);
        });

        // Global click to hide dropdown menu
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target) && !e.target.closest('.kebab-btn')) {
                hideDropdownMenu();
            }
        }, true); 

        // Context menu button clicks
        menuEdit.addEventListener('click', () => {
            if (currentContextMenuData) {
                showEditModal(currentContextMenuData.id, currentPage, currentContextMenuData.text);
            }
            hideDropdownMenu();
        });

        menuDelete.addEventListener('click', () => {
            if (currentContextMenuData) {
                const docId = currentContextMenuData.id; 
                showConfirmModal(async () => {
                    await deleteDoc(doc(db, currentPage, docId)); 
                });
            }
            hideDropdownMenu();
        });

        menuSelect.addEventListener('click', () => {
            enterSelectionMode();
            hideDropdownMenu(); 
        });

        // Selection bar button clicks
        selectionCancel.addEventListener('click', exitSelectionMode);
        selectionDelete.addEventListener('click', handleMultiDelete);


        // Handle Enter/Shift+Enter for Confessions
        confessionInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                confessionForm.requestSubmit(confessionButton);
            } else {
                updateTypingStatus(true);
            }
        });

        // Handle Enter/Shift+Enter for Chat
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                chatForm.requestSubmit(chatButton);
            } else {
                updateTypingStatus(true);
            }
        });

        // Start the application
        initFirebase();
    </script>

</body>

</html>